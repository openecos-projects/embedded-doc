# SYS_UART API

## 目录

一、初始化配置 (Initialization)

1. 系统串口初始化函数 (sys_uart_init)

二、数据传输接口 (Data Transfer APIs)

1. 字符输出函数 (sys_putchar)
2. 字符串输出函数 (sys_putstr)

## 详细介绍

### 一、初始化配置 (Initialization)

#### 1. 系统串口初始化函数 (sys_uart_init)
（1）功能描述

该函数用于调试串口的底层硬件配置，驱动程序通过宏 CONFIG_SYS_UART_IP_ID兼容不同的 UART IP 核心，可以建立波特率发生器的基准时钟分频，并锁定数据通信的帧格式。

（2）关键代码引用

```
// 引用自 sys_uart.c
#if CONFIG_SYS_UART_IP_ID == 1
    REG_UART_0_LC = REG_UART_0_LC | 0x80; // 开启 DLAB (除数锁存访问位)
    REG_UART_0_TH = 13 ;                  // 设定分频初值
    REG_UART_0_LC = 0x03;                 // 锁定 8N1 格式并关闭 DLAB
#endif
```

* DLAB 地址复用机制：在 16550 规范中，地址 0x00 具有双重身份，通过操作 LC 的 Bit 7，驱动可以在“数据收发寄存器”与“除数锁存寄存器”之间切换物理访问路径。
* 时钟频率匹配：代码中写入的 13 是针对 25MHz 系统主频产生的编码分频值，确保总线产生标准的 115200bps 采样脉冲。
* 物理协议锁存：最后一步将 LC 寄存器设为 0x03，不仅关闭了 DLAB 访问权限以恢复数据通信，还同时定义了物理链路为 8N1 格式，即8位数据、无校验位、1个停止位的格式。

### 二、数据传输接口 (Data Transfer APIs)

#### 1. 字符输出函数 (sys_putchar)
（1）功能描述

该接口可以将单个字节载入发送缓冲区，是由于 UART 是异步慢速设备，函数在写入寄存器前必须实时监控硬件状态，防止因 CPU 写入过快导致的数据覆盖错误。

（2）关键代码引用

```
// 引用自 sys_uart.c
#if CONFIG_SYS_UART_IP_ID == 1
    do {
        val = REG_UART_0_LS;              // 读取线路状态寄存器 (LSR)
    } while ((val & 0x20) == 0);          // 轮询 Bit 5 (THRE 标志位)
    REG_UART_0_TH = c;                    // 载入发送数据
#endif
```

* THRE 同步锁：LSR 寄存器的第 5 位（0x20）即 THRE ，是硬件给出的同步信号，只有该位为 1 时，才表示发送保持寄存器已空，允许软件写入下一个字节。
* 状态轮询机制：通过 do-while 结构进行强制等待，确保了软件层面的发送请求与硬件层面的并串转换时序完全同步，维持了输出字符的完整性。

#### 2. 字符串输出函数 (sys_putstr)
（1）功能描述

基于 sys_putchar 封装的批量发送函数，用于通过内存指针自动遍历并打印 C 语言标准的以 \0 结尾的字符串。

（2）关键代码引用

```
// 引用自 sys_uart.c
while (*str != '\0') {                // 识别字符串结束符
    sys_putchar(*str++);              // 串行调用底层接口并偏移指针
}
```

* 函数逻辑解释：该函数不直接触碰硬件寄存器，而是将“遍历字符串”这一通用逻辑提取出来。
* 边界自动识别：通过 while 循环检测空字符 \0 ，函数可以自适应处理不同长度的文本流，是实现系统 printf 等调试功能的基础。