# TIMER API

## 目录

一、系统时标配置 (System Timebase Configuration)

1. 系统时标初始化函数 (sys_tick_init)
2. 系统运行计数值获取函数 (get_sys_tick)

二、精密延迟接口 (Precision Delay APIs)

1. 微秒级精确延迟函数 (delay_us)
2. 毫秒/秒级通用延迟函数 (delay_ms / delay_s)

## 详细介绍

### 一、系统时标配置 (System Timebase Configuration)

#### 1. 系统时标初始化函数 (sys_tick_init)
（1）功能描述

该函数负责初始化硬件定时器，将其配置为全系统的全局计时基准，通过设定最大计数值并开启连续计数模式，为系统提供一个自启动以来单调递增的运行参考，用于后续的任务耗时统计和性能分析。

（2）关键代码引用

```
// 引用自 timer.c
REG_TIM_1_CONFIG = (uint32_t)0x0100;         // 步骤1：配置复位
REG_TIM_1_DATA = (uint32_t)0xFFFFFFFF;       // 步骤2：设定最大计数范围
REG_TIM_1_CONFIG = (uint32_t)0x0101;         // 步骤3：使能连续向上计数模式
```

* 配置状态机切换：代码先写入 0x0100 是为了强制停止定时器并清除之前的配置残留，确保计时器从一个确定的干净状态开始工作。
* 计数宽度设定：将 REG_TIM_1_DATA 初始化为 0xFFFFFFFF（32位最大值），可以确保在向上计数模式下拥有最长的溢出周期，提供稳定的长效计时支持。
* 硬件级无干扰计时：写入 0x0101 代表禁用中断并且开启连续计数，这种设计可以让定时器在硬件后台运行，不会触发 CPU 中断，从而不影响代码的执行效率。

#### 2. 系统运行计数值获取函数 (get_sys_tick)
（1）功能描述

该函数可以在读取并返回自系统上电并调用初始化函数后，硬件定时器累计跳过的总时钟周期数。

（2）关键代码引用

```
// 引用自 timer.c
return 0xFFFFFFFF - REG_TIM_1_DATA;
```

* 计数逻辑：由于底层硬件在向上计数模式下的寄存器读取特性，通过用最大值 0xFFFFFFFF 减去当前值，可以将硬件的剩余区间转换为软件易于理解的已运行周期。
* 高精度分辨率：该函数直接反馈硬件寄存器的数值，其单位为系统主频的时钟周期，例如在 25MHz 下，该计数值每增加 1 代表经过了 40 ns，具有极高的测量精度。

### 二、精密延迟接口 (Precision Delay APIs)

#### 1. 微秒级精确延迟函数 (delay_us)
（1）功能描述

该函数可以提供硬件级的微秒阻塞式延迟，接口利用硬件定时器归零触发机制，实现比软件循环更精准的时序控制，常用于总线电平维持等物理层驱动。

（2）关键代码引用

```
// 引用自 timer.c
REG_TIM_0_DATA = (uint32_t)(CONFIG_CPU_FREQ_MHZ * val - 1); // 步骤1：频率转换与校准
REG_TIM_0_CONFIG = (uint32_t)0x0101;                       // 步骤2：启动向下计数
while(REG_TIM_0_DATA != 0);                                // 步骤3：等待计数归零
```

* 时钟频率映射：CONFIG_CPU_FREQ_MHZ * val 的作用是将我们需要的“时间长度”换算成“时钟跳变次数”。这确保了可以在不同主频的板卡上，使实际延迟的物理时长保持一致。
* 指令执行开销补偿：公式中的 - 1 是极为严谨的校准操作，它抵消了 CPU 在执行“写入寄存器”和“启动定时器”这两行代码时所消耗的时间，使得微秒级的脉冲波形更接近理论设定。
* 硬件级忙等同步：通过 while 循环实时监控寄存器是否归零，寄存器是由底层晶振驱动的，这种硬件同步方式不受编译器优化或 CPU 流水线波动的影响。

#### 2. 毫秒/秒级通用延迟函数 (delay_ms / delay_s)
（1）功能描述

该函数是基于微秒接口构建的高层延时接口，用于实现人机交互等待或外设复位后的长等待。

（2）关键代码引用

```
// 引用自 timer.c
void delay_ms(uint32_t val){
    delay_us(val * 1000);                    // 1ms = 1000us
}
```

* 线性缩放：函数内部将毫秒单位按 1000 倍率转换为微秒，直接调用已校准的底层驱动逻辑。
* 封装设计：这种封装模式保证了全系统所有延迟函数都共用同一个硬件定时器逻辑，避免了在不同地方重复编写寄存器操作代码，极大地提高了驱动的可靠性和可维护性。























