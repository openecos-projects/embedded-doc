# LIBGCC API

## 目录

一、算术运算支持 (Arithmetic Operations)

1. 32位无符号整数乘法函数 (mulsi3)
2. 64位整数乘法函数 (muldi3)

二、位移运算支持 (Bitwise Operations)

1. 64位逻辑右移函数 (lshrdi3)

三、除法与取模运算 (Division & Modulo Operations)

1. 32位无符号整数除法函数 (udivsi3)
2. 32位无符号整数取模函数 (umodsi3)

   
## 详细介绍

### 一、算术运算支持 (Arithmetic Operations)

#### 1. 32位无符号整数乘法函数 (mulsi3)
（1）功能描述

该函数用于在缺乏硬件乘法指令的处理器架构上，通过软件逻辑实现两个 32 位无符号整数的乘法。

（2）关键代码引用

```
// 引用自 mulsi3.c
unsigned int r = 0;

while (a) {
    if (a & 1)
        r += b;      // 步骤1：如果乘数当前位为 1，则累加当前权值的被乘数
    a >>= 1;         // 步骤2：乘数右移，逐位检查
    b <<= 1;         // 步骤3：被乘数左移，实现权重的二进制翻倍
}
return r;
```

* 算法核心：采用经典的二进制移位相加法,其本质是将乘法拆解从而将复杂的乘法转化为基础的加法和位移。
* 按位累加：通过 if (a & 1) 提取乘数的每一位,只有当前比特位为 1 时，才将被乘数对应的权重值 b 加入结果 r 中。
* 权重处理：每轮循环执行 b <<= 1，模拟了二进制运算中的位权提升，确保加到结果中的数值处于正确的数量级。
* 提前终止优化：循环条件为 while (a)，当乘数的所有高位比特均处理为 0 后，函数会立即跳出，有效减少了小数值乘法的 CPU 时钟周期消耗。

#### 2. 64位整数乘法函数 (muldi3)
（1）功能描述

该函数提供对 64 位整数乘法的软件支持，由于 32 位系统单次操作只能处理 32 位数据，该函数利用分块乘法原理，将 64 位乘法分解为多个 32 位子乘法并合成最终结果。

（2）关键代码引用

```
// 逻辑参考 libgcc 实现
uint32_t u_low = (uint32_t)u, u_high = (uint32_t)(u >> 32);
uint32_t v_low = (uint32_t)v, v_high = (uint32_t)(v >> 32);

uint64_t res = (uint64_t)__mulsi3(u_low, v_low);             // 步骤1：计算低位部分乘积
res += (uint64_t)__mulsi3(u_low, v_high) << 32;     // 步骤2：计算交叉项 A 并对齐到高位
res += (uint64_t)__mulsi3(u_high, v_low) << 32;     // 步骤3：计算交叉项 B 并对齐到高位
```

* 跨字对齐：通过 << 32 操作，将 32 位乘法的结果精准地放置在 64 位结果的高半部分，实现从 32 位算术到 64 位结果的平滑过渡。
* 底层库复用：内部多次调用 __mulsi3，这种模块化设计确保了算术引擎的一致性，同时也压缩了库的代码体积。

### 二、位移运算支持 (Bitwise Operations)

#### 1. 64位逻辑右移函数 (lshrdi3)
（1）功能描述

该函数实现在 32 位硬件字宽下进行 64 位逻辑右移，解决了在物理寄存器宽度不足时，对比特流跨越寄存器边界搬移的控制问题。

（2）关键代码引用

```
// 引用自 lshrdi3.c
if (b < 32) {
    // 情况 1：位移量小于单个 32 位字宽
    result.u32.low = (input.u32.low >> b) | (input.u32.high << (32 - b));
    result.u32.high = input.u32.high >> b;
} else {
    // 情况 2：位移量大于等于 32 位
    result.u32.low = input.u32.high >> (b - 32);
    result.u32.high = 0;
}
```

* 内存映射：通过联合体将 64 位数据映射为两个 32 位成员，配合 BYTE_ORDER 宏，使代码能够自动适配大端或小端字节序，精准定位 low 和 high 字部分。
* 跨字比特补偿 ：在小额位移（< 32）时，高位字中即将移出的比特通过反向左移，被精准地搬移到低位字空出的高位端，从而保持了 64 位数据的连续性。
* 分段逻辑开关：当位移量 b >= 32 时，原低位字数据全部溢出丢弃，逻辑切换为将原高位字直接右移后填入低位寄存器。
* 代码逻辑保证：严格遵循逻辑右移在高位补零的定义，无论在何种情况下，result.u32.high 都会根据位移结果进行零填充。

### 三、除法与取模运算 (Division & Modulo Operations)

#### 1. 32位无符号整数除法函数 (udivsi3)
（1）功能描述

在缺乏硬件除法器指令的核心上，该函数可以通过软件逻辑去模拟 32 位无符号整数除法运算，并返回计算所得的商。

（2）关键代码引用

```
// 逻辑参考典型软件除法实现
unsigned int q = 0, r = 0;
for (int i = 31; i >= 0; i--) {
    r = (r << 1) | ((n >> i) & 1); // 步骤1：将被除数比特移入余数寄存器
    if (r >= d) {
        r -= d;                    // 步骤2：执行试减操作
        q |= (1U << i);            // 步骤3：标记对应的商位
    }
}
```

* 二进制试商法：通过 32 次迭代，逐个将被除数的位拉入临时余数，并与除数进行大小比较。
* 逐位标记：只有当临时余数大于等于除数时，才执行减法并将商的对应位置为 1，这种减法代替除法的思想是底层计算的核心。

#### 2. 32位无符号整数取模函数 (umodsi3)
（1）功能描述

该函数可以计算两个 32 位无符号整数相除后的余数，常用于校验算法或内存对齐逻辑。

（2）关键代码引用

```
// 逻辑参考
unsigned int r = 0;
for (int i = 31; i >= 0; i--) {
    r = (r << 1) | ((n >> i) & 1);
    if (r >= d) r -= d; // 核心逻辑：循环减法后保留的剩余值即为余数
}
return r;
```

* 资源合并：取模与除法函数在执行流程上完全一致，但在最终结果提取上有所区别。
* 轻量化设计：取模函数省去了对商变量 q 的维护，专注于获取减法循环后的最终剩余值。



